require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);



}).call(this,require('_process'))
},{"_process":9}],2:[function(require,module,exports){

function expressionInterpreter(expresion, contextObj) {
    let result;

    try {
        with (contextObj) {
            result = eval(expresion);
        }
    } catch (error) {
        if (error instanceof ReferenceError) {
            return false; //return false when it is not possible to evaluate
        } else {
            throw error; //other error
        }
    }
    return result;
}


module.exports = expressionInterpreter;
},{}],3:[function(require,module,exports){
const SignalComp = require('./SignalComp');

//Just avoid writing many times an empty function
let emptyFunction = function () {
};

class Layer {

    constructor(adap) {
        this._cond = adap.condition === undefined ?
            new SignalComp("false") : typeof (adap.condition) === "string" ?
                new SignalComp(adap.condition) : adap.condition; //it should be already a signal composition

        this._enter = adap.enter || emptyFunction;
        this._exit = adap.exit || emptyFunction;
        this._active = false;
        this._name = adap.name || "_";
        this.__original__ = adap;

        this._variations = [];
        this.enableCondition();
    }

    set name(name) {
        this._name = name;
    }

    get name() {
        return this._name;
    }

    //This method is only used for debugging
    get condition() {
        return this._cond;
    }

    cleanCondition() { //this method is reused when you re-init the condition
        this._cond = new SignalComp(this._cond.expression);
    }

    addVariation(obj, methodName, variation, originalMethod) {
        this._variations.push([obj, methodName, variation, originalMethod]);
    }

    _installVariations() {
        this._variations.forEach(function (variation) {
            let obj = variation[0];
            let methodName = variation[1];
            let variationMethod = variation[2];
            let originalMethod = variation[3];

            obj[methodName] = function () {
                Layer.proceed = function () {
                    return originalMethod.apply(obj, arguments);
                };
                let result = variationMethod.apply(obj, arguments);
                Layer.proceed = undefined;
                return result;
            };
        });
    }

    _uninstallVariations() {
        this._variations.forEach(function (variation) {
            let obj = variation[0];
            let methodName = variation[1];
            let originalMethod = variation[3];
            obj[methodName] = originalMethod;
        });
    }

    enableCondition() { //todo: when a condition is added, Should it check its predicate?
        let thiz = this;
        this._cond.on(function (active) {
            if (active !== thiz._active) {
                thiz._active = active;
                if (thiz._active) {
                    thiz._enter();
                    thiz._installVariations();
                } else {
                    thiz._exit();
                    thiz._uninstallVariations();
                }
            }
        });
    }

    isActive() { //This may be used only for debugging
        return this._active;
    }

    addSignal(signal) {
        this._cond.addSignal(signal);
    }
}

module.exports = Layer;



},{"./SignalComp":6}],4:[function(require,module,exports){
let Layer = require('./Layer');

class RAI {

    constructor() {
        if (!RAI.instance) {
            RAI.instance = this;
            this.init();
        }
        return RAI.instance;
    }

    init() {
        this._layers = []; //only layers
        this._signalInterfacePool = []; //objects x interface-object
        this._variations = []; //originalLayer x object x methodName x variation
        this._originalMethods = []; //object x name x original_method
    }

    deploy(originalLayer) {
        let layer = new Layer(originalLayer);
        layer._name = layer._name !== "_" ? layer._name : "Layer_" + (this._layers.length + 1);

        this._layers.push(layer);
        this._addSavedLayers(layer);

        //it is to know if signals are already send data
        this._receiveSignalsForSignalInterfaces(layer);
    }

    undeploy(originalLayer) {
        this._uninstallVariations(originalLayer);
        this._cleanSignalComposition(originalLayer);

        this._layers = this._layers.filter(function (layer) {
            return layer.__original__ !== originalLayer;
        });
    }

    _addSavedLayers(layer) {
        let variations = this._variations.filter(function (variation) {
            return layer.__original__ === variation[0];
        });
        var thiz = this;
        variations.forEach(function (variation) {
            let obj = variation[1];
            let methodName = variation[2];
            let variationMethod = variation[3];

            thiz._addOriginalMethod(obj, methodName);
            let originalMethod = thiz._getOriginalMethod(obj, methodName);
            layer.addVariation(obj, methodName, variationMethod, originalMethod);
        });
    }

    _uninstallVariations(originalLayer) {
        this._layers.forEach(function (layer) {
            if (layer.__original__ === originalLayer) {
                layer._uninstallVariations();
            }
        });
    }

    exhibit(object, signalInterface) {
        this._addSignalInterface(object, signalInterface);
        this._addIdSignal(signalInterface);
        this._exhibitAnInterface(signalInterface);
    }

    addPartialMethod(originalAdadp, obj, methodName, variation) {
        this._variations.push([originalAdadp, obj, methodName, variation]);
    }

    _receiveSignalsForSignalInterfaces(layer) {
        this._signalInterfacePool.forEach(function (si) {
            for (let field in si[1]) {
                if (si[1].hasOwnProperty(field)) {
                    layer.addSignal(si[1][field]);
                }
            }
        });
    }

    _addSignalInterface(object, signalInterface) {
        this._signalInterfacePool.push([object, signalInterface]);
    }

    _addIdSignal(signalInterface) {
        for (let field in signalInterface) {
            if (signalInterface.hasOwnProperty(field)) {
                signalInterface[field].id = field;
            }
        }
    }

    _exhibitAnInterface(signalInterface) {
        for (let field in signalInterface) {
            if (signalInterface.hasOwnProperty(field)) {

                this._layers.forEach(function (layer) {
                    layer.addSignal(signalInterface[field]);
                });
            }
        }
    }

    _addOriginalMethod(obj, methodName) {
        let originalMethod = this._getOriginalMethod(obj, methodName);

        if (originalMethod === undefined) {
            this._originalMethods.push([obj, methodName, obj[methodName]]);
        }
    }

    _getOriginalMethod(obj, methodName) {
        let found = this._originalMethods.find(function (tuple) {
            return obj === tuple[0] && methodName === tuple[1];
        });

        return found === undefined? undefined: found[2];
    }

    getLayers(filter) {
        filter = filter || function () {
            return true;
        };
        return this._layers.filter(filter);
    }

    getActiveLayers() {
        return this.getLayers(function (layer) {
            return layer.isActive()
        })
    };

    getInactiveLayers() {
        return this.getLayers(function (layer) {
            return !layer.isActive()
        })
    };

    _removingLayers(originalLayer) {
        this._variations = this._variations.filter(function (variation) {
            return originalLayer !== variation[0];
        });
    }

    _cleanSignalComposition(originalLayer) {
        let layer = this._layers.find(function (layer) {
            return layer.__original__ === originalLayer;
        });

        layer.cleanCondition();
    }
}

module.exports = new RAI();
},{"./Layer":3}],5:[function(require,module,exports){
const performance = require('performance-now');

class Signal {

    constructor(initialValue, id) {
        this._id = id || "_"; //it means does have an identifier
        this._subcribers = [];

        this._lastVal = undefined;
        this.value = initialValue;
    }

    get value() {
        return this._val;
    }

    get id() {
        return this._id;
    }

    get timestamp() {
        return this._timestamp;
    }

    set id(id) { //id to emit
        this._id = id;
    }

    set value(val) {
        if (this._lastVal !== val) {
            this._val = val;
            this._timestamp = performance();
            this._emit();
            this._lastVal = this._val;
        }
    }

    on(subscriber) {
        this._subcribers.push(subscriber);
    }

    _emit() {
        let val = this._val;
        let id = this._id;
        this._subcribers.forEach(function (subscriber) {
            subscriber(val, id);
        });
    }
}

module.exports = Signal;
},{"performance-now":1}],6:[function(require,module,exports){
const SMP = require('./StateMachineParser');
const expInter = require('./ExpressionInterpreter');
const performance = require('performance-now');

let SM_NAME = "__SM__";
let SM_OBJECT_CONTEXT = "objectContext";

class SignalComp {

    constructor(expression, signals, id) {
        this._expression = expression; //it is a parsed expression
        this._signals = signals || [];
        this._id = id || "_"; //used to emit

        this._subscribers = [];

        //to support state machine
        this._originalExpression = expression; //conserving state machine process variables
        this._sms = SMP.getSMExp(expression).map(function (smexp) {
            return SMP.createFromExp(smexp);
        });
        this._expression = SMP.replaceSmexpWithSM(this._expression, this._sms, SM_NAME, SM_OBJECT_CONTEXT);
        //end of state machine support

        this._enableSignals();
        this._lastVal = undefined;
    }

    get id() {
        return this._id;
    }

    get value() {
        return this._value;
    }

    get expression() {
        return this._expression;
    }

    get timestamp() {
        return this._timestamp;
    }

    set id(id) {
        this._id = id;
    }

    _isInExpression(id) {
        let exp = this._originalExpression;
        let variables = exp.match(/[a-zA-Z][a-zA-Z0-9_+-]*/g);
        return variables.indexOf(id) >= 0;
    }

    addSignals(signals) {
        let thiz = this;
        signals.forEach(signal => thiz.addSignal(signal));
    }

    addSignal(signal) {
        //if prevents of reentrancy issues (A in A, A in B && B in A)
        if (this._isInExpression(signal.id)) {
            this._signals.push(signal);
            this._enableSignal(signal);
        }
    }

    _enableSignal(signal) {
        let thiz = this; // a patch to evaluate a condition with a context
        signal.on(function () {
            return thiz.evaluate.apply(thiz);
        });

        return this.evaluate(); //evaluate the expression
    }

    _enableSignals() {
        for (let i = 0; i < this._signals.length; ++i) {
            this._enableSignal(this._signals[i]);
        }
    }

    on(subscriber) {
        this._subscribers.push(subscriber);
    }

    _emit() {
        let val = this._value;
        let id = this._id;
        this._subscribers.forEach(function (subscriber) {
            subscriber(val, id);
        });
    }

    evaluate() { //this method replaces set value
        let evalContext = this._prepareConditionContext();
        evalContext = this._addingStateMachine(evalContext);
        this._value = expInter(this._expression, evalContext);
        this._timestamp = performance();

        //console.log("\n------------");
        //console.log("EVALUATE:" + this._value + "--" + this._lastVal + " exp:"+this._originalExpression);
        if (this._value !== this._lastVal) {
            // console.log("UNA VEZ:" + this._value+ "--"+this._lastVal);
            this._lastVal = this._value;
            //    console.log("UNA VEZ (((2))):" + this._value+ "--"+this._lastVal);
            this._emit();
            //      console.log("LLEGO ACÃ:" + this._originalExpression);
        }

        return this._value;
    }

    _addingStateMachine(obj) {
        this._sms.forEach(function (sm, index) {
            obj[SM_NAME + index] = sm;
        });

        obj[SM_OBJECT_CONTEXT] = obj;
        return obj;
    };

    _prepareConditionContext() {
        this._signals.sort(function (sa, sb) {
            return sa.timestamp - sb.timestamp;
        });

        let obj = {}; //object context
        if (this._id !== "_") obj[this._id] = this.value;
        for (let i = 0; i < this._signals.length; ++i) {
            let signal = this._signals[i];
            obj[signal.id] = signal.value;
        }
        return obj;
    }
}

module.exports = SignalComp;
},{"./ExpressionInterpreter":2,"./StateMachineParser":8,"performance-now":1}],7:[function(require,module,exports){
const expInter = require('./ExpressionInterpreter');

function StateMachine(exp, smexp) {
    let tst = [exp];
    let resultSM = false;

    let sm = function (inputs) {
        tst = tst.filter(el => el !== true);
        tst = tst.map(function (st) {
            return st(inputs);
        });

        let first = exp(inputs);

        if (resultSM === true) {
            tst = [exp];
            if (first !== exp) {
                resultSM = false;
            }
        }
        if (first !== exp) {
            tst.push(first);
        }

        resultSM = resultSM || tst.some(val => val === true);
        return resultSM;
    };

    sm.addingContextObject = function (obj) {
        sm.contextObject = obj;
    };

    sm.expression = smexp || "_"; // it is just used to debugging
    return sm;
}

//this method is used only for tests
StateMachine.sym = function (id) {
    return function innerSym(s) {
        return s === id ? true : innerSym;
    }
};

StateMachine.exp = function (expression) {
    return function innerExp(contextObj) {
        return expInter(expression, contextObj) === true ? true : innerExp;
    }
};

StateMachine.seq = function (l1, l2) {
    return function innerSeq(s) {
        let r = l1(s);
        return r === true ? l2 : r === l1 ? innerSeq : StateMachine.seq(r, l2);
    }
};

StateMachine.seqN = function (list) {
    return list.reduce(function (acc, el) {
        return StateMachine.seq(acc, el);
    })
};

StateMachine.or = function (l1, l2) {
    return function innerOr(s) {
        let r1 = l1(s);
        let r2 = l2(s);

        return r1 === true || r2 === true ? true : r1 === l1 && r2 === l2 ? innerOr : StateMachine.or(r1, r2);
    }
};

StateMachine.star = function (l) {
    return function innerStar(s) {
        return l(s) === true ? innerStar : true;
    }
};

StateMachine.plus = function (l) {
    return StateMachine.seq(l, StateMachine.star(l));
};

module.exports = StateMachine;
},{"./ExpressionInterpreter":2}],8:[function(require,module,exports){
const SM = require('./StateMachine');

function StateMachineParser(exp) {
    return exp;
}

StateMachineParser.getSMExp = function (exp) {
    let results = exp.match(/\$.*?\$/g);
    if (results !== null) {
        results = results.map(function (result) {
            return result.substring(1, result.length - 1);
        });
    } else {
        results = [];
    }
    return results;
};

StateMachineParser.removeSMExp = function (exp) {
    return exp.replace(/\$.*?\$/g, "");
};

StateMachineParser.replaceSmexpWithSM = function (exp, sms, patternSMS, contextObjectName) {
    sms.forEach(function (sm, index) {
        //todo: think how to remove "$"
        exp = exp.replace("$" + sm.expression + "$", patternSMS + index + "(" + contextObjectName + ")");
    });
    return exp;
};

StateMachineParser.createFromExp = function (sexp) {
    let stexp = StateMachineParser.parse(sexp);
    let smexp;
    try {
        with (SM) {
            smexp = eval(stexp);
        }
    } catch (e) {
        console.error(stexp);
        throw "ERROR PARSING MACHINE:" + error;
    }
    return SM(smexp, sexp);
};

StateMachineParser.parse = function (code) {
    return StateMachineParser._transformer(StateMachineParser._parse(StateMachineParser._lex(code)));
};

StateMachineParser._lex = function (string) {
    //var tokens = string.match(/\(|\)|\|\d+(\.\d+)?|\w+|[+*\/-]/g);
    let tokens = string.match(/\(|\)|\|\||-->|->|>|<|&&|!|=|\d+(\.\d+)?|\w+|[+*\/-]/g);
    return tokens.map(function (token) {
        return /^\d/.test(token) ? parseFloat(token) : token;
    });
};

StateMachineParser._parse = function (tokens) {
    let nodes = [];
    tokens.shift();
    while (token = tokens.shift()) {
        if (token === "(") {
            tokens.unshift(token);
            nodes.push(StateMachineParser._parse(tokens));
        } else if (token === ")") {
            return nodes;
        } else {
            nodes.push(token);
        }
    }
    return nodes;
};

StateMachineParser._transformer = function (node) {
    if (!Array.isArray(node)) return "exp('" + node + "')";
    switch (node[0]) {
        case "||":
            return "or(" + StateMachineParser._transformer(node[1]) + "," + StateMachineParser._transformer(node[2]) + ")";
        case "->":
            return "seq(" + StateMachineParser._transformer(node[1]) + "," + StateMachineParser._transformer(node[2]) + ")";
        case "-->":
            return "seqN([" + node.splice(1).map(innerNode => StateMachineParser._transformer(innerNode)).join(",").slice(0, -1) + ")])";
        case "*":
            return "star(" + StateMachineParser._transformer(node[1]) + ")";
        case "+":
            return "plus(" + StateMachineParser._transformer(node[1]) + ")";
        default:
            return "exp('" + node.join("") + "')";
    }
};

module.exports = StateMachineParser;
},{"./StateMachine":7}],9:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"raijs":[function(require,module,exports){
const CSI = require('./src/RAI');
const Adaptation = require('./src/Layer');
const Signal =  require('./src/Signal');
const SignalComp = require('./src/SignalComp');

module.exports = {
    RAI: CSI,
    Adaptation: Adaptation,
    Signal: Signal,
    SignalComp: SignalComp,
    show: console.log
}; 
},{"./src/Layer":3,"./src/RAI":4,"./src/Signal":5,"./src/SignalComp":6}]},{},[]);
